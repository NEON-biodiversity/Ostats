% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get_ses.R
\name{get_ses}
\alias{get_ses}
\title{Calculation of standardized effect sizes of overlap statistics against null distributions}
\usage{
get_ses(o, o_n, qs)
}
\arguments{
\item{o}{A matrix data containing the observed normalized, local O-stats for each community.}

\item{o_n}{An array containing the local O-stats for each community generated by a null model.}

\item{qs}{A numeric vector of probabilities with values between zero and one to set the effect size quantiles, usually set to 0.025 and 0.975}
}
\value{
\item{ses}{a matrix containing values of standardized effect sizes for observed data of each of #' the locals (rows) and traits(columns) avaliated. To see if the overlap values can be expected by #' chance see returns ses_upper and ses_lower. If the value corresponding to the local in ses is between ses_upper and ses_lower, the overlapping between traits in community can be expected by chance.}
\item{ses_lower}{a matrix containing null values extracted for the quantile of qs[1] (usually 0.025)}
\item{ses_upper}{a matrix containing null values extracted for the quantile of qs[2] (usually 0.975)}
\item{raw_lower}{a matrix containing null values extracted for the quantile of qs[1] (usually 0.025) without subtracting the mean and divided by standard deviation (see equation for calculating the standardize effect size on the function code)}
\item{raw_upper}{a matrix containing null values extracted for the quantile of qs[2] (usually 0.975) without subtracting the mean and divided by standard deviation (see equation for calculating the standardize effect size on the function code)}
}
\description{
Calculates standardized effect sizes for the overlap statistics using null models. See the *Ostats* function documentation for a description of the local null models.
}
\details{
To explore the drivers of variation in body size overlap, the *Ostats* function can implement a null model to test whether individual species' body size distributions are more evenly spaced along the trait axis than expected by chance, finding the z-score of each observed community evaluated against the distribution of a user defined number of null communities in which species body size means may be shuffled randomly, retaining the shape and width of the distribution around the mean for each species. The *get_ses* function calculates standardized effect sizes from the randomly generated permutations of the null model community subsets.

These effect size values are used to compare the observed overlap statistics with a local null model (z-score test). If the ses (standard effect sizes) value is lower than the lower limit for that community, it suggests that the community overlap value observed is lower than expected by chance from a null model. Similarly, if the community overlap value is higher than the upper limit, the community has a higher overlap than expected by chance.
}
\examples{
# Load data from Read et al. (2018) from Figshare web archive
dat <- read_csv('https://ndownloader.figshare.com/files/9167548')

# Keep only sites "HARV" and "JORN" using the filter function, and select the relevant columns required  # by the function.
# Use the mutate function to add a new column named "log_weight" to log-transform the measurements.

dat <- dat \%>\%
   filter(siteID \%in\% c('HARV','JORN')) \%>\%
   select(siteID, taxonID, weight) \%>\%
   filter(!is.na(weight)) \%>\%
   mutate(log_weight = log10(weight))

# Group the data by siteID and taxonID and look at the summary
dat \%>\%
   group_by(siteID, taxonID) \%>\%
   slice(1)

# Specify variables plots and taxa to create matrices to hold outputs of the community_overlap_merged function, which operates within the Ostats function.
plots <- factor(dat$siteID)
sp <- factor(dat$taxonID)
# Number of permutations for null model outputs
nperm <- 99

# Create matrices to store outputs the observed O-Stats. The number of columns is set to one because Ostats only works with univariate trait responses.
overlaps_norm <- matrix(nrow = nlevels(plots), ncol = 1)
overlaps_unnorm <- matrix(nrow = nlevels(plots), ncol = 1)

# Create matrices to store the normalized and non-normalized outputs of the null models
overlaps_norm_null <- array(dim = c(nrow = nlevels(plots), ncol = 1, nperm))
overlaps_unnorm_null <- array(dim = c(nrow = nlevels(plots), ncol = 1, nperm))

# Name rows and columns of the outputs.
dimnames(overlaps_norm) <- list(levels(plots), names(dat)[4])
dimnames(overlaps_unnorm) <- list(levels(plots), names(dat)[4])

# Set the "o" argument - the overlap between observed data, looping through each plot (i.e., community)
for (s in 1:nlevels(plots)) {
   overlap_norm_st <- try(community_overlap_merged(traits = traits[plots == levels(plots)[s], 1], sp = sp[plots == levels(plots)[s]], data_type ="linear"), TRUE)
   overlaps_norm[s, 1] <- if (inherits(overlap_norm_st, 'try-error')) NA else overlap_norm_st
   overlap_unnorm_st <- try(community_overlap_merged(traits = traits[plots == levels(plots)[s], 1], sp = sp[plots == levels(plots)[s]], data_type ="linear"), TRUE)
   overlaps_unnorm[s, 1] <- if (inherits(overlap_unnorm_st, 'try-error')) NA else overlap_unnorm_st
}

# Set the "o_n" argument - the overlap between null model data generated from random subsets
# Do not shuffle weights or swap mean of traits between species during null community subset generation.
shuffle_weights <- FALSE
swap_means <- FALSE
# Loop through each permutation and plot (i.e., community)
for (i in 1:nperm) {
 for (s in 1:nlevels(plots)) {
    if (!shuffle_weights & !swap_means) overlap_norm_sti <- try(community_overlap_merged(traits = traits[plots == levels(plots)[s], 1], sp = sample(sp[plots == levels(plots)[s]]), data_type = "linear"), TRUE)
     if (shuffle_weights) overlap_norm_sti <- try(community_overlap_merged(traits = traits[plots == levels(plots)[s], 1], sp = sp[plots == levels(plots)[s]], norm=TRUE, randomize_weights = TRUE, data_type = "linear"), TRUE)
     if (swap_means) {
       traits_st <- traits[plots==levels(plots)[s], 1]
       sp_st <- sp[plots==levels(plots)[s]]

       traitmeans <- tapply(traits_st,sp_st,mean)
       traitdeviations <- traits_st-traitmeans[sp_st]

       # Sort the trait means out randomly.
       traitmeans_null <- sample(traitmeans)
       sp_null <- rep(names(traitmeans_null), table(sp_st))
       traits_null <- traitdeviations + traitmeans_null[sp_null]
       overlap_norm_sti <- try(community_overlap_merged(traits = traits_null, sp = sp_null, norm =TRUE, randomize_weights = FALSE, data_type = "linear"), TRUE)
     }

     overlaps_norm_null[s, 1, i] <- if (inherits(overlap_norm_sti, 'try-error')) NA else overlap_norm_sti
     overlap_unnorm_sti <- try(community_overlap_merged(traits = traits[plots == levels(plots)[s] , 1], sp = sample(sp[plots == levels(plots)[s]]), data_type = "linear"), TRUE)
     overlaps_unnorm_null[s, 1, i] <- if (inherits(overlap_unnorm_sti, 'try-error')) NA else overlap_unnorm_sti
 }
}

# Calculate standardized effect sizes
SES <- get_ses(o = overlaps_norm, o_n =overlaps_norm_null, qs = c(0.025, 0.975))
}
\seealso{
\code{\link{Ostats}} to Calculate O-statistics (community-level pairwise niche overlap statistics)
}
