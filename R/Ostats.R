#' Calculate O-statistics (community-level pairwise niche overlap statistics)
#'
#' This is the primary function in the Ostats package. It evaluates the
#' O-statistics against a local null model.
#'
#' @param traits a vector of trait measurement with nrow = n individuals.
#' @param plots a factor with length equal to nrow(traits) that indicates the
#'   community each individual belongs to.
#' @param sp a factor with length equal to nrow(traits) that indicates the taxon
#'   of each individual.
#' @param data_type data type can be "linear", "circular",or "circular_discrete".
#'   Defaults to "linear".
#' @param output specifies whether median or mean is calculated.
#' @param weight_type specifies weights to be used to calculate the median or mean.
#' @param nperm the number of permutations to generate a null model.
#' @param nullqs numeric vector of probabilities with values in [0,1] to set
#'   effect size quantiles.
#' @param shuffle_weights If TRUE, shuffle weights given to pairwise overlaps
#'   within a community when generating null models.
#' @param swap_means If TRUE, swap means of body sizes within a community when
#'   generating null models.
#' @param circular_args optional list of additional arguments to pass to
#'  \code{\link[circular]{circular}}. Only used if the data type is "circular".
#' @param ... additional arguments to pass to \code{\link[stats]{density}}, such as
#' \code{bw}, \code{n}, or \code{adjust}. If none are provided, default values
#' are used.
#'
#' @details This function evaluates the overlap statistics against a local null
#'   model.The function community_overlap_merged calculates the community overlap
#'   statistics in each community. At default, it calculates the median of pairwise
#'   overlaps, weighted by harmonic mean of species abundaces of the species
#'   pairs in each community. Two results are produced, one normalizing the area
#'   under all density functions to 1, the other making the area under all density
#'   functions proportional to the number of observations in that group.
#'
#'   When both shuffle_weights and swap_means are FALSE, null models are
#'   generated by randomly assigning a taxon that is present in the community to
#'   each individual. O-stats are then calculated to be compared against.
#'
#'   Effect size statistics are calculated between the observed O-stats
#'   and the null model.

#'
#' @return The funtion returns a list containing 4 objects:
#' \item{overlaps_norm}{a matrix showing the median of weighted pairwise overlaps (at default) of trait
#'   distributions of all species in each community (at default output
#'   and weight_type), with the area under all density functions normalized to 1.}
#' \item{overlaps_unnorm}{a matrix showing O-stats calculated with the area under all density
#'   functions proportional to the number of observations in that group.}
#' \item{overlaps_norm_ses}{5 matrices of effect size statistics against a null model
#'   with the area under all density functions normalized to 1.}
#' \item{overlaps_unnorm_ses}{5 matrices of effect size statistics against a null model
#'   with the area under all density functions proportional to the number
#'   of observations in that group.}
#'
#' @references Read, Q. D. et al. Among-species overlap in rodent body size
#'   distributions predicts species richness along a temperature gradient.
#'   Ecography 41, 1718-1727 (2018).
#'
#' @author Quentin D. Read, John M. Grady, Arya Y. Yue, Isadora Fluck E., Ben Baiser,
#' Angela Strecker, Phoebe L. Zarnetske, and Sydne Record
#'
#' @seealso \code{\link{Ostats_regional}} to evaluate against a regional null
#'   model.
#'
#' @seealso \code{\link{Ostats_circular}} for circular distributions.
#' @seealso \code{\link{community_overlap_merged}} for median of
#' pairwise overlaps of species trait distributions within a community.
#' @seealso \code{\link{get_ses}} for standardized effect sizes from null
#' model values.
#' @seealso \code{\link{Ostats_plot}} for plotting community overlap for
#' each community.
#'
#' @examples
#' # overlap statistics for body weights of species in NEON sites
#' library(tidyverse)
#' library(Ostats)
#' # Load data from web archive
#' dat <- read_csv('https://ndownloader.figshare.com/files/9167548')
#'
#' # Keep only the relevant part of data
#' dat <- dat %>%
#'   filter(siteID %in% c('HARV','JORN')) %>%
#'   select(siteID, taxonID, weight) %>%
#'   filter(!is.na(weight)) %>%
#'   mutate(log_weight = log10(weight))
#'
#' dat %>%
#'   group_by(siteID, taxonID) %>%
#'   slice(1)
#'
#' #Run O-stats on the data with nperm = 2 (do not bother with null models)
#' Ostats_example <- Ostats(traits = as.matrix(dat$log_weight),
#'                    sp = factor(dat$taxonID), data_type = "linear",
#'                    plots = factor(dat$siteID),
#'                    nperm = 2)
#' @export
#'
#'
Ostats <- function(traits, plots, sp, data_type = 'linear', output = "median", weight_type= "hmean", nperm = 99, nullqs = c(0.025, 0.975), shuffle_weights = FALSE, swap_means = FALSE, circular_args = list(), ...) {
  # Required input: a matrix called traits (nrows=n individuals, ncols=n traits),
  # a vector called plots which is a factor with length equal to nrow(traits),
  # a vector called sp which is a factor with length equal to nrow(traits),

  # Collect arguments to density()
  density_args <- list(...)

  # Declaration of data structures to hold the results

  # Data structures for observed O-Stats
  overlaps_norm <- matrix(nrow = nlevels(plots), ncol = ncol(traits))
  overlaps_unnorm <- matrix(nrow = nlevels(plots), ncol = ncol(traits))

  # Data structures for null O-Stats
  overlaps_norm_null <- array(dim = c(nlevels(plots), ncol(traits), nperm))
  overlaps_unnorm_null <- array(dim = c(nlevels(plots), ncol(traits), nperm))

  # Name rows and columns of the outputs.
  dimnames(overlaps_norm) <- list(levels(plots), dimnames(traits)[[2]])
  dimnames(overlaps_unnorm) <- list(levels(plots), dimnames(traits)[[2]])

  # Calculation of observed O-Stats

  print('Calculating observed local O-stats for each community . . .')
  pb <- txtProgressBar(min = 0, max = nlevels(plots), style = 3)

  for (s in 1:nlevels(plots)) {
    for (t in 1:ncol(traits)) {
      overlap_norm_st <- try(community_overlap_merged(traits = traits[plots == levels(plots)[s], t], sp = sp[plots == levels(plots)[s]], data_type=data_type, output = output, weight_type = weight_type, normal=TRUE, circular_args = circular_args, density_args = density_args), TRUE)
      overlaps_norm[s, t] <- if (inherits(overlap_norm_st, 'try-error')) NA else overlap_norm_st
      overlap_unnorm_st <- try(community_overlap_merged(traits = traits[plots == levels(plots)[s], t], sp = sp[plots == levels(plots)[s]], data_type=data_type, output = output, weight_type = weight_type, normal=FALSE, circular_args = circular_args, density_args = density_args), TRUE)
      overlaps_unnorm[s, t] <- if (inherits(overlap_unnorm_st, 'try-error')) NA else overlap_unnorm_st
    }
    setTxtProgressBar(pb, s)
  }

  close(pb)

  print('Calculating null distributions of O-stats . . . ')
  pb <- txtProgressBar(min = 0, max = nperm, style = 3)

  # Null model generation and calculation of null O-Stats

  # Local null model: generation and calculation done in the same loop
  for (i in 1:nperm) {
    setTxtProgressBar(pb, i)
    for (s in 1:nlevels(plots)) {
      for (t in 1:ncol(traits)) {
        if (!shuffle_weights & !swap_means) overlap_norm_sti <- try(community_overlap_merged(traits = traits[plots == levels(plots)[s], t], sp = sample(sp[plots == levels(plots)[s]]), data_type=data_type, output = output, weight_type = weight_type, normal=TRUE, circular_args = circular_args, density_args = density_args), TRUE)
        if (shuffle_weights) overlap_norm_sti <- try(community_overlap_merged(traits = traits[plots == levels(plots)[s], t], sp = sp[plots == levels(plots)[s]], data_type=data_type, output = output, weight_type = weight_type, normal=TRUE, randomize_weights = TRUE, circular_args = circular_args, density_args = density_args), TRUE)
        if (swap_means) {
          traits_st <- traits[plots==levels(plots)[s], t]
          sp_st <- sp[plots==levels(plots)[s]]

          traitmeans <- tapply(traits_st,sp_st,mean)
          traitdeviations <- traits_st-traitmeans[sp_st]

          # Sort the trait means out randomly.
          traitmeans_null <- sample(traitmeans)
          sp_null <- rep(names(traitmeans_null), table(sp_st))
          traits_null <- traitdeviations + traitmeans_null[sp_null]
          overlap_norm_sti <- try(community_overlap_merged(traits = traits_null, sp = sp_null, data_type=data_type, output = output, weight_type = weight_type,normal=TRUE, randomize_weights = FALSE, circular_args = circular_args, density_args = density_args), TRUE)
        }

        overlaps_norm_null[s, t, i] <- if (inherits(overlap_norm_sti, 'try-error')) NA else overlap_norm_sti
        overlap_unnorm_sti <- try(community_overlap_merged(traits = traits[plots == levels(plots)[s], t], sp = sample(sp[plots == levels(plots)[s]]),data_type=data_type, output = output, weight_type = weight_type, normal=FALSE, circular_args = circular_args, density_args = density_args), TRUE)
        overlaps_unnorm_null[s, t, i] <- if (inherits(overlap_unnorm_sti, 'try-error')) NA else overlap_unnorm_sti
      }
    }
  }

  close(pb)
  print('Extracting null quantiles to get standardized effect sizes (almost done!) . . .')

  # Extract quantiles to get standardized effect sizes for the overlap stats
  overlaps_norm_ses <- get_ses(overlaps_norm, overlaps_norm_null, nullqs)
  overlaps_unnorm_ses <- get_ses(overlaps_unnorm, overlaps_unnorm_null, nullqs)
  list(overlaps_norm=overlaps_norm, overlaps_unnorm=overlaps_unnorm,
       overlaps_norm_ses=overlaps_norm_ses, overlaps_unnorm_ses=overlaps_unnorm_ses)

}

#' Calculate O-statistics evaluated against regional null model
#'
#' This function evaluates the O-statistics (community-level pairwise niche
#' overlap statistics)against a regional null model. In contrast to
#' \code{Ostats}, it requires trait and species information about the regional
#' species pool.
#'
#' @param traits a vector of trait measurement with nrow = n individuals.
#' @param plots a factor with length equal to nrow(traits) that indicates the
#'   community each individual belongs to.
#' @param sp a factor with length equal to nrow(traits) that indicates the taxon
#'   of each individual.
#' @param reg_pool_traits trait measurements in the species regional pool to
#'   compare the dataset with.
#' @param reg_pool_sp species identification for each measurement in the
#'   regional species pool.
#' @param nperm the number of permutations to generate a null model.
#' @param nullqs numeric vector of probabilities with values in [0,1] to set
#'   effect size quantiles.
#' @param ... additional arguments to pass to \code{\link[stats]{density}}, such
#'   as \code{bw}, \code{n}, or \code{adjust}. If none are provided, default
#'   values are used.
#'
#' @details This function evaluates the overlap statistics against a regional
#'   null model. It takes all individual trait measurements in the community to
#'   compare with the regional pool (ignoring species identity) to calculate
#'   pairwise overlap for each community, which indicates the regional pool
#'   space a community takes up.
#'
#'   Total pool null model is generated by sampling n trait measurements (n =
#'   number of trait measurements for the community) from the regional pool and
#'   calculate the pairwise_overlap between the random sample and the regional
#'   pool. By-species null model is calculated by sampling trait measurements of
#'   the same species from the regional pool for each species present in the
#'   community to calculate pairwise overlap between the sample and the whole
#'   regional pool.
#'
#'   In this function, the area under all density functions are normalized to 1.
#'
#' @return The funtion returns a list containing 4 objects:
#'   \item{overlaps_reg}{pairwise overlap output between the trait data and the
#'   regional species pool.}
#'   \item{overlaps_reg_allpool_ses}{effect size
#'   statistics between observed O-stats and the total-pool null model}
#'   \item{overlaps_reg_bysp_ses}{effect size statistics between observed
#'   O-stats and the by-species null model}
#'
#' @author Quentin Read, John Grady, Arya Y. Yue, Isadora Fluck E., Ben Baiser,
#'   Angela Strecker, Phoebe Zarnetske, and Sydne Record
#'
#' @seealso \code{\link{Ostats}} to evaluate against a local null model.
#' @seealso \code{\link{pairwise_overlap}} to calculate overlap between two
#'   empirical density estimates.
#' @seealso \code{\link{get_ses}} for standardized effect sizes from null model
#'   values.
#'
#' @examples
#' library(tidyverse)
#'
#' # use the 2015 data from the two communities HARV and BART
#' sites2015 <- reg_pool %>%
#' filter(siteID=='HARV'|siteID == 'BART') %>%
#' filter(substring(as.character(endDate),1,4)=="2015")
#'
#' # making the overall data (HARV and BART, sites from the same domain)
#' the regional pool across space and time
#' reg_pool_traits <- list (as.matrix(reg_pool$log_weight), as.matrix(reg_pool$log_weight))
#' reg_pool_sp <- list(as.matrix(reg_pool$taxonID), as.matrix(reg_pool$taxonID))
#' names(reg_pool_traits) <- c("HARV", "BART")
#' names(reg_pool_sp) <- c("HARV", "BART")
#' Ostats_reg_example <- Ostats_regional(traits = as.matrix(sites2015$log_weight),
#'                                      plots = factor(sites2015$siteID),
#'                                      sp = factor(sites2015$taxonID),
#'                                      reg_pool_traits = reg_pool_traits,
#'                                      reg_pool_sp = reg_pool_sp,
#'                                      nperm = 2)
#'
#' @export
Ostats_regional <-function(traits, plots, sp, reg_pool_traits, reg_pool_sp, nperm = 99, nullqs = c(0.025, 0.975), ...) {
  # Collect arguments to density()
  density_args <- list(...)

  # Declaration of data structures to hold the results

	# Data structures for observed O-Stats
	overlaps_reg <- matrix(nrow = nlevels(plots), ncol = ncol(traits))

	# Data structures for null O-Stats
	allpool_overlaps_reg_null <- array(dim = c(nlevels(plots), ncol(traits), nperm))
	bysp_overlaps_reg_null <- array(dim = c(nlevels(plots), ncol(traits), nperm))

	# Name rows and columns of the outputs.
	dimnames(overlaps_reg) <- list(levels(plots), dimnames(traits)[[2]])

	# Calculation of observed O-Stats

	print('Calculating observed regional O-stats for each community . . .')
	pb <- txtProgressBar(min = 0, max = nlevels(plots), style = 3)

	for (s in 1:nlevels(plots)) {
		for (t in 1:ncol(traits)) {
			overlap_reg_st <- try(pairwise_overlap(a = traits[plots == levels(plots)[s], t], b = `[[`(reg_pool_traits, levels(plots)[s])[, t], normal = TRUE, density_args = density_args), TRUE)
			overlaps_reg[s, t] <- if(inherits(overlap_reg_st, 'try-error')) NA else overlap_reg_st[1]
		}
		setTxtProgressBar(pb, s)
	}

	close(pb)

	print('Calculating total-pool and species-pool null distributions of regional O-stats . . . ')
	pb <- txtProgressBar(min = 0, max = nperm, style = 3)

	# Null model generation and calculation of null O-Stats

	# Total-pool null model: generation and calculation done in the same loop
		for (i in 1:nperm) {
			for (s in 1:nlevels(plots)) {
				for (t in 1:ncol(traits)) {
					trnull_sti <- sample(x=`[[`(reg_pool_traits, levels(plots)[s])[, t], size=sum(plots == levels(plots)[s]), replace=FALSE)
					allpool_overlap_reg_sti <- try(pairwise_overlap(a = trnull_sti, b = `[[`(reg_pool_traits, levels(plots)[s])[, t], normal = TRUE), TRUE)
					allpool_overlaps_reg_null[s, t, i] <- if (inherits(allpool_overlap_reg_sti, 'try-error')) NA else allpool_overlap_reg_sti[1]
				}
			}

	# By-species null model: generation of null communities and calculation of O-stats (in same loop)


		for (s in 1:nlevels(plots)) {
			for (t in 1:ncol(traits)) {
				sp_sti <- sp[plots == levels(plots)[s]]
				trnull_sti <- c()
				spnames_sti <- unique(sp_sti)
				sptable_sti <- table(sp_sti)

				for (j in 1:length(spnames_sti)) {
					z <- `[[`(reg_pool_traits, levels(plots)[s])[`[[`(reg_pool_sp, levels(plots)[s]) == as.character(spnames_sti[j]), t]
					if (any(!is.na(z))) trnull_sti <- c(trnull_sti, sample(x=z, size=sum(sp_sti == spnames_sti[j]), replace=FALSE))
				}

				bysp_overlap_reg_sti <- try(pairwise_overlap(a = trnull_sti, b = `[[`(reg_pool_traits, levels(plots)[s])[, t], normal = TRUE), TRUE)
				bysp_overlaps_reg_null[s, t, i] <- if (inherits(bysp_overlap_reg_sti, 'try-error')) NA else bysp_overlap_reg_sti[1]

			}
		}
		setTxtProgressBar(pb, i)
	}

	close(pb)
	print('Extracting null quantiles to get standardized effect sizes (almost done!) . . .')

	overlaps_reg_allpool_ses <- get_ses(overlaps_reg, allpool_overlaps_reg_null, nullqs)
	overlaps_reg_bysp_ses <- get_ses(overlaps_reg, bysp_overlaps_reg_null, nullqs)

	list(overlaps_reg=overlaps_reg, overlaps_reg_allpool_ses=overlaps_reg_allpool_ses, overlaps_reg_bysp_ses=overlaps_reg_bysp_ses)


}


#' Calculate O-statistics using circular distributions
#'
#' This is a version of the O-statistics function that works with circular distributions.
#' Circular distributions are only implemented for the local null model, not regional.
#'
#' Defaults to use 24-hour clock as units for the circular distribution.
#' This is a simplified non-flexible version that only does the "manual" density calculation.
#'
#' @seealso \code{\link{Ostats}} for non-circular distributions.
#'
#' @export
Ostats_circular <- function(traits, plots, sp, nperm = 99, nullqs = c(0.025, 0.975), shuffle_weights = FALSE, swap_means = FALSE) {
  ### FIXME this function should be deprecated -- functionality taken over by Ostats()

  # Required input: a matrix called traits (nrows=n individuals, ncols=n traits),
  # a vector called plots which is a factor with length equal to nrow(traits),
  # a vector called sp which is a factor with length equal to nrow(traits),

  # Declaration of data structures to hold the results

  # Data structures for observed O-Stats
  overlaps_norm <- matrix(nrow = nlevels(plots), ncol = ncol(traits))
  overlaps_unnorm <- matrix(nrow = nlevels(plots), ncol = ncol(traits))

  # Data structures for null O-Stats
  overlaps_norm_null <- array(dim = c(nlevels(plots), ncol(traits), nperm))
  overlaps_unnorm_null <- array(dim = c(nlevels(plots), ncol(traits), nperm))

  # Name rows and columns of the outputs.
  dimnames(overlaps_norm) <- list(levels(plots), dimnames(traits)[[2]])
  dimnames(overlaps_unnorm) <- list(levels(plots), dimnames(traits)[[2]])

  # Calculation of observed O-Stats

  print('Calculating observed local O-stats for each community . . .')
  pb <- txtProgressBar(min = 0, max = nlevels(plots), style = 3)

  for (s in 1:nlevels(plots)) {
    for (t in 1:ncol(traits)) {
      overlap_norm_st <- try(community_overlap_circular(traits = traits[plots == levels(plots)[s], t], sp = sp[plots == levels(plots)[s]], norm = TRUE), TRUE)
      overlaps_norm[s, t] <- if (inherits(overlap_norm_st, 'try-error')) NA else overlap_norm_st
      overlap_unnorm_st <- try(community_overlap_circular(traits = traits[plots == levels(plots)[s], t], sp = sp[plots == levels(plots)[s]], norm=FALSE), TRUE)
      overlaps_unnorm[s, t] <- if (inherits(overlap_unnorm_st, 'try-error')) NA else overlap_unnorm_st
    }
    setTxtProgressBar(pb, s)
  }

  close(pb)

  print('Calculating null distributions of O-stats . . . ')
  pb <- txtProgressBar(min = 0, max = nperm, style = 3)

  # Null model generation and calculation of null O-Stats

  # Local null model: generation and calculation done in the same loop
  for (i in 1:nperm) {
    setTxtProgressBar(pb, i)
    for (s in 1:nlevels(plots)) {
      for (t in 1:ncol(traits)) {
        if (!shuffle_weights & !swap_means) overlap_norm_sti <- try(community_overlap_circular(traits = traits[plots == levels(plots)[s], t], sp = sample(sp[plots == levels(plots)[s]]), norm=TRUE), TRUE)
        if (shuffle_weights) overlap_norm_sti <- try(community_overlap_circular(traits = traits[plots == levels(plots)[s], t], sp = sp[plots == levels(plots)[s]], norm=TRUE, randomize_weights = TRUE), TRUE)
        if (swap_means) {
          traits_st <- traits[plots==levels(plots)[s], t]
          sp_st <- sp[plots==levels(plots)[s]]

          traitmeans <- tapply(traits_st,sp_st,mean)
          traitdeviations <- traits_st-traitmeans[sp_st]

          # Sort the trait means out randomly.
          traitmeans_null <- sample(traitmeans)
          sp_null <- rep(names(traitmeans_null), table(sp_st))
          traits_null <- traitdeviations + traitmeans_null[sp_null]
          overlap_norm_sti <- try(community_overlap_circular(traits = traits_null, sp = sp_null, norm=TRUE, randomize_weights = FALSE), TRUE)
        }

        overlaps_norm_null[s, t, i] <- if (inherits(overlap_norm_sti, 'try-error')) NA else overlap_norm_sti
        overlap_unnorm_sti <- try(community_overlap_circular(traits = traits[plots == levels(plots)[s], t], sp = sample(sp[plots == levels(plots)[s]]), norm=FALSE), TRUE)
        overlaps_unnorm_null[s, t, i] <- if (inherits(overlap_unnorm_sti, 'try-error')) NA else overlap_unnorm_sti
      }
    }
  }

  close(pb)
  print('Extracting null quantiles to get standardized effect sizes (almost done!) . . .')

  # Extract quantiles to get standardized effect sizes for the overlap stats
  overlaps_norm_ses <- get_ses(overlaps_norm, overlaps_norm_null, nullqs)
  overlaps_unnorm_ses <- get_ses(overlaps_unnorm, overlaps_unnorm_null, nullqs)
  list(overlaps_norm=overlaps_norm, overlaps_unnorm=overlaps_unnorm,
       overlaps_norm_ses=overlaps_norm_ses, overlaps_unnorm_ses=overlaps_unnorm_ses)

}
